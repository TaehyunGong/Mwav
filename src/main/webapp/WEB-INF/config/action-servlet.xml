<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns:context="http://www.springframework.org/schema/context"
	xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">

	<!-- net 하위 모든 패키지에 있는 파일의 어노테이션을 스캔해서 빈으로 등록하겠다는 말 즉 사용하는 bean을 일일이 xml에 
		선언하지 않고도 필요한 것을 어노테이션(Annotation)을 자동으로 인식하게 하는 역할 -->
	<context:component-scan base-package="net"></context:component-scan>

	<!-- 구글 프로퍼티 파일 연결 -->
	<bean
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="ignoreResourceNotFound" value="true" />
		<property name="locations">
			<list>
				<value>classpath:googleProperties/googleApi.properties</value>
				<value>classpath:googleProperties/version.properties</value>
				<value>classpath:googleProperties/datasource.properties</value>
			</list>
		</property>
	</bean>

	<!-- restTemplate 사용위한 bean 생성 -->
	<bean id="jsonConverter"
		class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter">
		<property name="supportedMediaTypes" value="application/json" />
	</bean>

	<bean id="restTemplate" class="org.springframework.web.client.RestTemplate">
		<property name="messageConverters">
			<list>
				<ref bean="jsonConverter" />
			</list>
		</property>
	</bean>


	<!-- 파일 업로드 MultipartResolver 설정 CommonsMultipartResolver 등록 / CommonsMultipartResolver은 
		스프링 파일업로드 기능 구현 10MB로 설정 제대로 설정안하면, java.lang.classcastexception multiparthttpservletrequest 
		오류발생 -->
	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<property name="maxUploadSize" value="100000000" />
		<property name="maxInMemorySize" value="100000000" />
		<property name="defaultEncoding" value="UTF-8" />
	</bean>


	<!--servlet-context는 서블릿 영영의 설정하는 XML 파일 -->

	<!-- 스프링 메일 설정 -->
	<!-- gmail -->
	<!-- 이메일 보내기 -->
	<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
		<property name="host" value="smtp.gmail.com" /> <!-- 서버주소 -->
		<property name="port" value="587" /> <!-- 포트번호 기본 25 -->
		<property name="defaultEncoding" value="utf-8" /> <!-- 기본인코딩 -->
		<property name="username" value="ebizpromwav@gmail.com" /> <!-- 메일주소 -->
		<property name="password" value="qkqh5501" /> <!-- 메일비밀번호 -->
		<property name="javaMailProperties">
			<props>
				<prop key="mail.transport.protocol">smtp</prop>
				<prop key="mail.smtp.auth">true</prop>
				<prop key="mail.smtp.starttls.enable">true</prop>
				<prop key="mail.debug">true</prop>
			</props>
		</property>
	</bean>


	<!-- <bean id="email" class="net.mwav.mail.EmailVO"> </bean> -->
	<bean id="emailTemplates" class="net.mwav.common.module.EmailTemplates">
	</bean>
	<bean id="emailSender" class="net.mwav.common.module.EmailSender">
	</bean>




	<!-- Responsebody annotation스캔을 <mvc:annotation-driven/> 로 하고 있다면 HttpMessageConverter를 
		기본적으로 등록하기 때문에 별다른 설정없이 Jackson 라이브러리만 추가하면 디폴트 전략인 Jackson Json을 사용할 수 있다는 
		것. -->
	<bean id="jacksonMessageConverter"
		class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter" />


	<!-- Enables the Spring MVC @Controller programming model -->
	<!-- CustomMapArgumentResolver는 root context 영역에 등록이 되어야 한다. -->
	<mvc:annotation-driven> <!-- 어노테이션을 사용하겠다고 선언 -->
		<mvc:argument-resolvers> <!-- <mvc:argument-resolvers> 태그를 이용하여 우리가 만든 CustomMapArgumentResolver의 
				빈(bean)을 수동으로 등록했다. -->
			<bean class="net.common.resolver.CustomMapArgumentResolver"></bean>
		</mvc:argument-resolvers>
	</mvc:annotation-driven>

	<!-- Interceptor는 Controller가 요청되기 전에 수행된다. 즉, Interceptor는 DispatcherServlet과 
		같은 위치에 등록이 되어있어야지 정상적으로 수행이 된다. -->
	<!-- Log4js 설정 http://dev.anyframejava.org/docs/anyframe/plugin/essential/core/1.6.0/reference/html/ch21.html 
		http://logging.apache.org/log4j/1.2/apidocs/index.html -->
	<!-- 20160223 admin 권한부여를 위하여 변경 <mvc:interceptors> <mvc:interceptor> <mvc:mapping 
		path="/**" /> 지금 작성하는 로거는 모든 요청에서 동작을 하기때문에 전체 패스를 의미하는 "/**" 로 설정하였다. <bean 
		id="loggerInterceptor" class="net.common.logger.LoggerInterceptor"></bean> 
		</mvc:interceptor> </mvc:interceptors> -->
	<!-- 제외하고 싶을떄 http://krespo.net/192 -->

	<mvc:interceptors>
		<mvc:interceptor>
			<mvc:mapping path="/admins/**" />
			<bean id="loggerInterceptor" class="net.common.logger.LoggerInterceptor"></bean>
		</mvc:interceptor>
	</mvc:interceptors>

	<bean
		class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping" />

	<bean class="org.springframework.web.servlet.view.BeanNameViewResolver"
		p:order="0" />
	<bean id="jsonView"
		class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" />


	<!-- Resolves views selected for rendering by @Controllers to .jsp resources 
		in the /WEB-INF/views directory -->
	<!-- ViewResolver구요~ jsp와 name을 매핑시켜주는 녀석 Controller을 설명할 때, 서블릿 설정이 자동으로 
		prefix와 suffix를 붙인다고 해줬는데, 그 역할을 담당한다. 즉, 우리가 일일이 전체경로와 .jsp를 붙이지 않아도 되도록 
		도와준다. -->
	<!-- 위에 prefix로 컨트롤러로 넘겨주는 url 결정 만약 /WEB-INF/views 로 되어있다면 앞에 자동으로 붇는다. -->
	<bean class="org.springframework.web.servlet.view.UrlBasedViewResolver"
		p:order="1" p:viewClass="org.springframework.web.servlet.view.JstlView"
		p:prefix="/" p:suffix=".jsp">  <!-- prefix는 페이지의 기본 루트 // 페이지의 기본 확장자 -->

	</bean>

	<context:property-placeholder
		location="classpath:googleProperties/datasource.properties" />
	<context:property-placeholder
		location="classpath:googleProperties/application.properties" />

	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.user}" />
		<property name="password" value="${jdbc.pass}" />
	</bean>

	<bean id="dataSourceSpied" class="net.sf.log4jdbc.Log4jdbcProxyDataSource">
		<constructor-arg ref="dataSource" />
		<property name="logFormatter">
			<bean class="net.sf.log4jdbc.tools.Log4JdbcCustomFormatter">
				<property name="loggingType" value="MULTI_LINE" />
				<property name="sqlPrefix" value="SQL : " />
			</bean>
		</property>
	</bean>

	<!-- <bean id="dataSourceSpied" class="org.apache.commons.dbcp.BasicDataSource" 
		destroy-method="close"> <property name="driverClassName" value="org.gjt.mm.mysql.Driver"/> 
		읽어온 정보를 매핑시켜 가지고 있는 빈 <property name="url" value="jdbc:mysql://localhost:3306/mwav"/> 
		<property name="username" value="mwav"/> <property name="password" value="tiger"/>12485154 
		// tiger <property name="maxActive" value="100"/> <property name="maxWait" 
		value="1000"/> </bean> -->

	<!-- <bean id="dataSource" class="net.sf.log4jdbc.Log4jdbcProxyDataSource"> 
		<constructor-arg ref="dataSourceSpied" /> <property name="logFormatter"> 
		<bean class="net.sf.log4jdbc.tools.Log4JdbcCustomFormatter"> <property name="loggingType" 
		value="MULTI_LINE" /> <property name="sqlPrefix" value="SQL : "/> </bean> 
		</property> </bean> -->

	<bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 데이터베이스 정보 name은 위에서 등록한 sqlSession 빈(bean)에서 사용할 이름이 dataSource이고, 
			ref의 dataSource는 우리가 context-datasource.xml에서 정의한 빈(bean)을 참조하는 것을 의미한다. 
			
			dataSourceSpied 위의 log4.js와 연결되어 쿼리 출력
			-->
		<property name="dataSource" ref="dataSourceSpied" />

		<!-- 매퍼 xml이 있는 경로 정의 SQL이 위치할 mapper 폴더를 잡아주고, 그 안에 모든 폴더를 의미하는 **를 붙여준 
			후, 마지막으로 _SQL로 끝나는 모든 xml 파일을 읽어주도록 한다 -->
		<property name="mapperLocations" value="classpath:/mapper/**/*_SQL.xml" />
	</bean>
	<!-- 10번째 줄의 sqlSessionTemplate은 마이바티스 스프링 연동모듈의 핵심이다. SQLSessionTemplate은 
		SqlSession을 구현하고, 코드에서 SqlSessoin을 대체하는 역할을 한다. -->
	<bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg index="0" ref="sqlSession" />
	</bean>

	<import resource="mvc.xml" />

	<import resource="data.xml" />

	<import resource="spring-security.xml" />

</beans>


